# 재귀함수, Recursion Function

>  함수 내부에서 ‘자기 자신을 호출’하는 함수를 의미한다. 이를 통해서 함수가 자신을 반복적으로 호출하면서 원하는 결과를 도출할 수 있다.

## 재귀호출을 사용하는 이유?

1. 가독성이 좋다.
   
   - for문 같은 반복문을 사용하는 것보다 알고리즘을 기술한 그래도 표현이 가능하기 때문에 코드에 대한 직관적인 이해가 가능하다.

2. 변수의 사용을 줄여준다.
   
   - 처음에 받은 변수를 그대로 다음 호출에서도 사용하기 때문에 생각하지 못한 변수 사용을 줄여서 오류가 발생할 수 있는 가능성을 줄여준다. 변수가 가질 수 있는 값의 종료 또는 범위도 제한하게 되어 함수를 단순하게 만들고 불변적으로 유지할 수 있게 한다.

### 재귀 함수 설계시 고려해야 하는 부분?

1. 순환되지 않고 종료되는 casr가 무조건 존재해야한다. 이것을 주로 'base case'라고 한다.
   
   - 기본 사례(Base Case): 재귀 함수에서는 항상 하나 이상의 기본 사례가 있어야 한다. 이는 재귀 호출이 종료되는 지점을 정의한다. 기본 사례가 없으면 함수는 무한히 호출될 수 있다.[참고1](https://jelong.tistory.com/entry/%EC%9E%90%EB%B0%94-%EC%9E%AC%EA%B7%80Recursion-%ED%95%A8%EC%88%98%EB%9E%80-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%B4%EB%B3%B4%EC%9E%90)
   
   - 재귀 사례(Recursice Case): 재귀 함수에서는 자기 자신을 호출하는 부분이 있어야 한다. 이 부분은 함수가 문제를 더 작은 조각으로 나누고 해결하기 위해 자신을 호출한다. 이 과정은 기본 사례가 만족될 때까지 반복된다.

2. 명시적 매개 변수를 사용해야한다.

### [재귀 호출의 단점?](https://velog.io/@ssuh0o0/JavaAlgorithm-%EC%9E%AC%EA%B7%80%ED%98%B8%EC%B6%9C)

- 자바에서 재귀를 사용하지 않는 것을 권장한다.(?) 잘못 사용할 경우 무한 루프에 빠져 스택 오버 플로우가 발생할 수 있고, 무한루프에 빠지지 않더라고 함수의 매개변수/지연변수/반환값 함수의 위치가 메모리에 쌓이면서 satck이 점점 쌓여 이 역시 스택 오버플로우를 발생시킬 수 있기 때문이다.

### 재귀 호출 최적화, Tail Call

- 스택 오버 플로우를 막는 방법

- 꼬리 호출, Tail Call

- 재귀 호출이 스택 오버 플로우가 생기는 이유는 원래 자리로 돌아와서 해야할 일이 남아 있는 경우 원래 자리의 저보를 stack에 쌓게 되는데, 이때 stack이 넘쳐 오버플로우가 생기는 것이다.

- Tail Call은 함수를 호출해서 값을 반환 받은 후 아무 일도 하지 않고 바로 반환하게 하기 위해 논리적으로 가장 마지막(꼬리) 위치에서 함수를 호출하는 방식이다.

```java
static int factorial(int n) { //일반 재귀
    if (n > 0) {
        return n * factorial(n-1); //반환(return)부에 연산이 존재
    } else {
        return 1; //정지 조건
    }
}
```

> 일반 재귀

```java
static int factorial(int n, int total) { //꼬리 재귀
    if(n == 1) {
        return total; //정지 조건 -> 바로 팩토리얼의 값을 리턴
    }
    return factorial(n - 1, n * total);
}
```

> 꼬리 재귀

[참고2](https://rebugs.tistory.com/168)

### 꼬리 호출 최적화, TCO

- Tail Call을 하기 위해서는 return 받고나서 아무것도 수행하는 게 있으면 안된다.  
  왼쪽 처럼 계속해서 다른 값을 더하게 저장하고 있으면 안되고, 오른쪽과 같이 return 한 후 마무리가 되어야한다.
  
  ![](https://velog.velcdn.com/images/ssuh0o0/post/650fe0ce-df53-4205-b3f3-c68fe34c9187/image.png)

- stack은 아래와 같이 변수와 return을 저장하고 계속 쌓이게 되는데, 이때 Tail Call 방식을 사용하게 되면 스택이 쌓이지 않고, 하나의 함수 호출 스택을 재사용 할 수 있다. Tail Call을 사용하게 되면 n과 m 파라미터를 바꿔서 계속 연산하면 되고, 그 전의 값인 'n = 10, m = 0'은 가지고 있지 않아도 된다.
  
  ![](https://velog.velcdn.com/images/ssuh0o0/post/88526ac3-2a5e-4d08-802c-4356749dc616/image.png)

### [재귀함수를 이용한 알고리즘](https://adjh54.tistory.com/194)

- 피보나치 수열
  
  - 이전 두 항의 합이 다음 항이 되는 수열
  
  - 첫번째 항과 두번째 항이 1이고 이후 모든 항은 바로 앞 두 항의 합으로 이루어지는 수열
    
    - ex) 1, 1, 2, 3, 5, 8, 13, 21, 34,...
      
      ```java
      public static int fibonacci(int n) {
          if (n == 0) {
              return 0;
          } else if (n == 1) {
              return 1;
          } else {
              return fibonacci(n-1) + fibonacci(n-2);
          }
      }
      ```
      
      

- 유클리드 호제법
  
  - 두 수의 "최대 공약수(GCD)"를 찾기 위한 알고리즘
  
  - 큰 수를 작은 수로 나누어 떨어지게 하여 수를 반복적으로 취하여 나머지 0이 될 때까지 작동하는 방법 > 이때 작은 수가 최대 공약수
    
    ```java
    public static int gcd(int m, int n) {
        if (n == 0) {
            return m;
        } else {
            return gcd(n, m % n);
        }
    }
    ```

- 이진 탐색
  
  - 정렬된 배열에서 원하는 데이터를 빠르게 찾기 위한 알고리즘
  
  - 배열의 중간값을 선택한 후, 찾고자하는 데이터와 중간값을 비교 > 만약 중간값이 찾고자하는 데이터보다 크다면 중간값의 왼쪽 부분 배열에서 다시 중간값을 선택하여 비교 > 이 과정 반복
  
  - 데이터의 개수가 많을 때도 빠르게 데이터를 찾을 수 있기 때문에 많이 사용되는 알고리즘 중 하나
    
    > 높은 인덱스가 낮은 인덱스보다 크거나 같은지 확인
    > 
    > 1. 중간 값을 구한다.
    > 
    > 2. 배열의 요소 값이 찾는 값과 동일하면 중간 값을 반환한다.
    > 
    > 3. 중간 값이 키보다 큰 경우: 낮은 인덱스와 중간 인덱스에서 1을 뺀 값을 가지고 함수를 재귀적으로 호출한다.
    > 
    > 4. 중간 값이 키보다 작은 경우: 중간 인덱스에 1을 더하고 높은 인덱스와 함께 함수를 재귀적으로 호출한다.
    
    ```java
    /**
     * 재귀를 사용하여 이진 알고리즘을 구현합니다.
     * @param arr 배열
     * @param low 낮은 인덱스
     * @param high 높은 인덱스
     * @param key 검색할 값
     * @return
     */
    public static int binarySearch(int[] arr, int low, int high, int key) {
        // 1. 높은 인덱스가 낮은 인덱스보다 크거나 같은지 확인합니다.
        if (high >= low) {
    
        // 2. 중간 값을 구합니다.
        int mid = low + (high - low) / 2;
    
        // 3. 배열의 요소 값이 찾는 값과 동일하면 중간 값을 반환합니다.
        if (arr[mid] == key) {
            return mid;
        }
    
        // 4. 중간 값이 키보다 큰 경우 : 낮은 인덱스와 중간 인덱스에서 1을 뺀 값을 가지고 함수를 재귀적으로 호출합니다.
        else if (arr[mid] > key) {
            return binarySearch(arr, low, mid - 1, key);
        }
    
        // 5. 중간 값이 키보다 작은 경우 : 중간 인덱스에 1을 더하고 높은 인덱스와 함께 함수를 재귀적으로 호출합니다
        else {
            return binarySearch(arr, mid + 1, high, key);
        }
    }
    
    // 6. 높은 인덱스가 낮은 인덱스보다 작으면 배열에서 키를 찾지 못했음을 나타내기 위해 -1을 반환합니다.
    return -1;
    }
    ```
    
    

- 이항 계수
  
  - 조합론에서 사용되며, n개의 서로 다른 원소에서 r개의 원소를 선택하는 경우의 수
    
    > 원소 n개 중에서 r개를 선택하는 경우의 수를 계산하는 함수
    > 
    > 1. r이 0이거나 n과 같으면 함수는 1을 반환
    > 
    > 2. 그렇지 않으면 k-1과 n-1인자로 하여 자기 자신을 두 번 호출하고 두 결과의 합을 반환
    > 
    > 3. 이 과정은 k가 0이나 n과 같아질 때까지 반복
    
    ```java
    public static int binomialCoefficient(int n, int k) {
        if (k == 0 || k == n) {
            return 1;
        } else {
            return binomialCoefficient(n-1, k-1) + binomialCoefficient(n-1, k);
        }
    }
    ```

### [정리](https://leejaedoo.github.io/optimizing_recursions/)

- 재귀는 프로그래밍에서 상단히 유용한 기법이지만, 재귀를 간단하게 구현하기는 어렵다.

- 함수형 인터페이스, 람다 표현식, 무한 스트림 등 활용하면 꼬리 호출을 설계하는 데 도움이 되고 더욱 효과적으로 재귀를 활용할 수 있다.
